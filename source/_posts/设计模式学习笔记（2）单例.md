---
layout:     post
title:      "设计模式学习笔记（2）-单例"
subtitle:   ""
date:       2017-11-29 12:00:00
categories:
    - 设计模式
tags:
    - 设计模式
    - Java
---


## 前言
单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？
作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~
<!-- more -->
## 什么是单例？
单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。
>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。
>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法

## 实例

> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程

## 模式分析

> 先来看最简单的写法

```java
public class Single {
    private static Single instance;
    public static Single getInstance() {
        if (instance == null) {
            instance = new Single();
        }
        return instance;
    }
}
```

> 稍作修改，把构造器改为私有的，防止被外部的类调用

```java
public class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了

> 在 getInstance() 方法上添加 synchronized 关键字

```java
public class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```
> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率

> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法

```java
public class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```
> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例

> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如

```java
int a;      //语句 A
a = 3;      //语句 B
int b = 5;      //语句 C
int c = a + b;  //语句 D
```
> 可能会被重排成 A-C-B-D 或者 C-A-B-D
>
> 语句 C 和语句 D 不具备原子性，因此也有可能被重排
> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错
>
> 于是有了最终版本，添加 volatile 关键字

```java
public class Singleton {
    private static volatile Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```
> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作

> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的

```java
public enum Singleton {
    INSTANCE;
}
```

> 通过枚举类获取单例的实例
```
Singleton result = Singleton.INSTANCE;
```

### 知识点：什么时候是类装载时？

> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？

> 不严格的说，大致有这么几个条件会触发一个类被加载：
> 1. new一个对象时
> 2. 使用反射创建它的实例时
> 3. 子类被加载时，如果父类还没被加载，就先加载父类
> 4. jvm启动时执行的主类会首先被加载

## 适用场景

>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它
>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例

## 总结

可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响。但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。


## 开源项目
本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。
