---
title:      "设计模式学习笔记（9）命令"
date:       2018-04-25 22:00:20
categories:
    - 设计模式
tags:
    - 设计模式
    - Java
---
本文实例代码：[https://github.com/JamesZBL/java_design_patterns](https://github.com/JamesZBL/java_design_patterns)

命令（Command）模式是一种数据驱动的设计模式，它属于行为型模式。请求被包装成一个命令对象，并由调用者传递给被调用对象。被调用对象寻找可以处理该命令的合适的处理对象，并把该命令传给这个处理对象，该处理对象执行命令。

命令模式中，命令的发出者和接收者是独立的，发出命令的职责和处理命令的职责被分别指派给不同的对象。命令模式解决了一般的调用过程中，“行为请求者”与“行为实现者” 之间的强耦合关系。比如某些场合中，需要对命令进行“撤销”、“重做”，亦或其他不得不以 “事务” 的形式实现的场合，命令发出者和命令实现者之间的解耦就显得至关重要了。

<!-- more -->
# 实例

命令模式最常见的场景就是字处理软件了，软件必须允许使用者进行重做或撤销的操作，仿佛没有这种特性的字处理软件几乎不会有人乐意使用。

首先不考虑使用命令模式，而是以传统的对象间调用来实现这种需求。假设我们现在需要对某个字依次进行如下操作：增大字号、设置字体颜色为红色、设置为加粗，那么对于命令发出者，要处理的逻辑就是这样的：

```
if(改变字号){
    if(增大字号){
        字号渲染器.增大字号();
    }else if(减小字号){
        字号渲染器.减小字号();
    }
}
if(改变颜色){
    颜色渲染器.改变颜色(颜色);
}
if(改变粗细){
    if(加粗){
        粗细渲染器.加粗();
    }else if(不加粗){
        粗细渲染器.变细();
    }
}
```
这种 “紧耦合” 的结构下，行为请求者与行为实现者之间的关系大概是这样的：

图片

首先，所有命令都要有对应的处理者去执行，这就意味着行为请求者需要持有多个处理者的引用。这样，每修改或添加一个命令就必须修改行为请求者的逻辑，没办法实现对扩展开放。其次，如果要实现对命令的撤销或重做，那么本来就复杂的行为判断逻辑会变得愈发臃肿，对程序员来说这简直是一场灾难。



# 总结
